#!/usr/bin/env ruby

require "erb"
require_relative "list_eg_gems"
require "set" # Added for Set

module ElasticGraph
  class CodebaseOverviewRenderer
    PROJECT_ROOT = File.expand_path("..", __dir__)

    def initialize(template)
      @erb = ::ERB.new(template, trim_mode: "-")
    end

    def render
      @erb.result(binding)
    end

    def gem_specs
      @gem_specs ||= ::ElasticGraphGems.list.map do |gem_name|
        ::Gem::Specification.load("#{PROJECT_ROOT}/#{gem_name}/#{gem_name}.gemspec")
      end
    end

    def gem_categories
      @gem_categories ||= begin
        specs_by_category = gem_specs.group_by do |spec|
          spec.metadata.fetch("gem_category") { raise "No category set for #{spec.name}." }.tap do |category|
            unless CategoryInfo::BY_NAME.key?(category)
              raise "Unrecognized gem category `#{category}` found on gem: #{spec.name}."
            end
          end
        end

        CategoryInfo::BY_NAME.map do |category, category_info|
          specs = specs_by_category.fetch(category)
          GemCategory.new(category, category_info, specs, gem_specs)
        end
      end
    end
  end

  class IndividualGemReadmeProcessor

    def initialize(gem_spec, all_specs, project_root)
      @gem_spec = gem_spec
      @all_specs = all_specs # This should be an array of Gem::Specification objects
      @project_root = project_root
      @readme_path = File.join(@project_root, @gem_spec.name, "README.md") 
    end

    def direct_dependencies
      @gem_spec.runtime_dependencies.map(&:name)
    end

    def direct_internal_dependents
      dependents = []
      current_gem_name = @gem_spec.name
      @all_specs.each do |other_spec|
        next if other_spec.name == current_gem_name
        if other_spec.runtime_dependencies.any? { |dep| dep.name == current_gem_name }
          dependents << other_spec.name
        end
      end
      dependents.uniq.sort
    end

    public def generate_mermaid_diagram
      deps = direct_dependencies
      dependents = direct_internal_dependents
      current_gem_name = @gem_spec.name

      mermaid_lines = ["graph LR;"]
      all_node_names_in_diagram = Set.new([current_gem_name])

      if deps.empty?
        mermaid_lines << "    #{current_gem_name} --> no_deps[(No direct dependencies)];"
        all_node_names_in_diagram.add("no_deps")
      else
        deps.each do |dep_name|
          mermaid_lines << "    #{current_gem_name} --> #{dep_name};"
          all_node_names_in_diagram.add(dep_name)
        end
      end

      if dependents.empty?
        mermaid_lines << "    no_eg_dependents[(No direct EG dependents)] --> #{current_gem_name};"
        all_node_names_in_diagram.add("no_eg_dependents")
      else
        dependents.each do |dep_name|
          mermaid_lines << "    #{dep_name} --> #{current_gem_name};"
          all_node_names_in_diagram.add(dep_name)
        end
      end
      
      mermaid_lines << "    classDef currentGemStyle fill:#lightblue,stroke:#333,stroke-width:2px;"
      mermaid_lines << "    classDef internalEgGemStyle fill:#lightgreen,stroke:#333,stroke-width:1px;"
      mermaid_lines << "    classDef externalGemStyle fill:#lightcoral,stroke:#333,stroke-width:1px;"
      mermaid_lines << "    classDef placeholderNodeStyle fill:#eee,stroke:#333,stroke-width:1px;"

      all_node_names_in_diagram.each do |node_name|
        style_class = case node_name
                      when current_gem_name
                        "currentGemStyle"
                      when "no_deps", "no_eg_dependents"
                        "placeholderNodeStyle"
                      else
                        if @all_specs.any? { |s| s.name == node_name }
                          "internalEgGemStyle"
                        else
                          "externalGemStyle"
                        end
                      end
        mermaid_lines << "    class #{node_name} #{style_class};"
      end

      "```mermaid\n#{mermaid_lines.join("\n")}\n```"
    end

    public def perform_readme_pre_flight_check
      unless File.exist?(@readme_path)
        return { status: :error, message: "README for #{@gem_spec.name} at #{@readme_path} is missing." }
      end

      content = File.read(@readme_path)
      if content.strip.empty?
        return { status: :error, message: "README for #{@gem_spec.name} at #{@readme_path} is empty." }
      end

      first_line = content.lines.first
      unless first_line && first_line.start_with?("# ")
        return { status: :error, message: "README for #{@gem_spec.name} at #{@readme_path} does not start with an H1 title." }
      end

      { status: :ok, content: content }
    end
    
    private def _isolate_intro_and_tail(readme_lines_after_h1)
      intro_lines = []
      tail_lines = []
      
      end_of_intro_index = readme_lines_after_h1.find_index { |line| line.strip.start_with?("## ") }
      
      if end_of_intro_index.nil?
        intro_lines = readme_lines_after_h1
      else
        intro_lines = readme_lines_after_h1[0...end_of_intro_index]
        h2_onwards_lines = readme_lines_after_h1[end_of_intro_index..-1]
        diagram_heading_index_in_h2_onwards = h2_onwards_lines.find_index { |line| line.strip == "## Dependency Diagram" }
        
        if diagram_heading_index_in_h2_onwards
          tail_lines.concat(h2_onwards_lines[0...diagram_heading_index_in_h2_onwards])
          current_search_index = diagram_heading_index_in_h2_onwards + 1
          mermaid_block_started = false
          mermaid_block_ended = false
          
          while current_search_index < h2_onwards_lines.length
            line_strip = h2_onwards_lines[current_search_index].strip
            if !mermaid_block_started && line_strip == "```mermaid"
              mermaid_block_started = true
            elsif mermaid_block_started && line_strip == "```"
              current_search_index += 1 
              mermaid_block_ended = true
              break 
            end
            current_search_index += 1
          end
          
          if mermaid_block_started && mermaid_block_ended
            tail_lines.concat(h2_onwards_lines[current_search_index..-1] || [])
          end
        else
          tail_lines = h2_onwards_lines
        end
      end
      
      {
        intro_content: intro_lines.join.strip,
        tail_content: tail_lines.join.strip
      }
    end

    public def construct_expected_readme(actual_readme_content, new_mermaid_diagram_block)
      lines = actual_readme_content.lines
      h1_line = lines.first.strip 
      
      readme_lines_after_h1 = lines[1..-1] || []
      parsed_parts = _isolate_intro_and_tail(readme_lines_after_h1)

      components = [h1_line] 
      
      intro_text = parsed_parts[:intro_content]
      unless intro_text.empty?
        components << "" 
        components << intro_text
      end
      
      components << "" 
      components << "## Dependency Diagram"
      components << "" 
      components << new_mermaid_diagram_block.strip 
      
      tail_text = parsed_parts[:tail_content]
      unless tail_text.empty?
        components << "" 
        components << tail_text
      end
      
      final_content = components.join("\n") + "\n"
      final_content.gsub(/\n{3,}/, "\n\n") 
    end

    public def process
      pre_flight_result = perform_readme_pre_flight_check
      
      return pre_flight_result if pre_flight_result[:status] == :error
      
      actual_content = pre_flight_result[:content]
      
      new_mermaid_diagram = generate_mermaid_diagram
      expected_content = construct_expected_readme(actual_content, new_mermaid_diagram)
      
      { 
        status: :ok, 
        actual_content: actual_content, 
        expected_content: expected_content, 
        gem_name: @gem_spec.name, 
        readme_path: @readme_path 
      }
    end

  end

  class GemCategory < ::Data.define(:category_name, :info, :gem_specs, :all_eg_gem_specs)
    def mermaid_definition
      <<~MERMAID
        ```mermaid
        graph LR;
        #{mermaid_deps.join("\n")}
        #{mermaid_styles.join("\n")}
        #{mermaid_clicks.join("\n")}
        ```
      MERMAID
    end

    private

    def mermaid_deps
      gem_specs.filter_map do |spec|
        unless spec.runtime_dependencies.empty?
          deps = spec.runtime_dependencies.map(&:name).join(" & ")
          "    #{spec.name} --> #{deps}"
        end
      end
    end

    def mermaid_styles
      all_nodes = gem_specs.map(&:name) | gem_specs.flat_map { |spec| spec.runtime_dependencies.map(&:name) }
      all_nodes.map do |node|
        "    style #{node} #{style_for(node)};"
      end
    end

    def style_for(gem_name)
      # These colors were chosen to look good on GitHub in both light mode and dark mode.
      if gem_specs.any? { |spec| spec.name == gem_name }
        "color: DodgerBlue" # Basic "Blue" doesn't look good in dark mode.
      elsif all_eg_gem_specs.any? { |spec| spec.name == gem_name }
        "color: Green"
      else
        "color: Red"
      end
    end

    def mermaid_clicks
      gem_specs.flat_map { |spec| spec.runtime_dependencies.map(&:name) }.uniq.sort.filter_map do |gem_name|
        unless all_eg_gem_specs.any? { |spec| spec.name == gem_name }
          "click #{gem_name} href \"https://rubygems.org/gems/#{gem_name}\""
        end
      end
    end
  end

  class CategoryInfo < ::Data.define(:description, :discussion)
    BY_NAME = {
      "core" => new("Core Libraries", <<~EOS),
        These libraries form the core backbone of ElasticGraph that is designed to run in a production deployment. Every ElasticGraph deployment will need to use all of these.
      EOS

      "lambda" => new("AWS Lambda Integration Libraries", <<~EOS),
        These libraries wrap the the core ElasticGraph libraries so that they can be deployed using AWS Lambda.
      EOS

      "extension" => new("Extensions", <<~EOS),
        These libraries extend ElasticGraph to provide optional but commonly needed functionality.
      EOS

      "datastore_adapter" => new("Datastore Adapters", <<~EOS),
        These libraries adapt ElasticGraph to your choice of datastore (Elasticsearch or OpenSearch).
      EOS

      "local" => new("Local Development Libraries", <<~EOS)
        These libraries are used for local development of ElasticGraph applications, but are not intended to be deployed to production (except for `elasticgraph-rack`).
        `elasticgraph-rack` is used to boot ElasticGraph locally but can also be used to run ElasticGraph in any rack-compatible server (including a Rails application).
      EOS
    }
  end
end

# Placeholder for all_specs loading, will be done once in the main script body
# all_specs_for_readme_processing = ::ElasticGraphGems.list.map do |gem_name|
#   ::Gem::Specification.load(File.join(ElasticGraph::CodebaseOverviewRenderer::PROJECT_ROOT, gem_name, "#{gem_name}.gemspec"))
# end

renderer = ElasticGraph::CodebaseOverviewRenderer.new(DATA.read)
contents = renderer.render
readme_path = ::File.join(__dir__, "..", "CODEBASE_OVERVIEW.md")

case ARGV.first
when "--verify"
  if ::File.read(readme_path) == contents
    puts "✅ CODEBASE_OVERVIEW is up-to-date."
  else
    tmp_path = ::File.join(__dir__, "..", "tmp", "CODEBASE_OVERVIEW.md")
    ::File.write(tmp_path, contents)

    diff = `git diff --no-index #{readme_path} #{tmp_path} #{" --color" unless ENV["CI"]}`

    puts "❌ CODEBASE_OVERVIEW is out-of-date. Run `#{__FILE__}` to update it. Diff:"
    puts
    puts diff
    exit(1) # For now, only CODEBASE_OVERVIEW failure causes exit in verify
  end
when nil
  ::File.write(readme_path, contents)
  puts "CODEBASE_OVERVIEW.md updated."
else
  raise "Unknown argument: #{ARGV.first}. Expected `--verify` or nothing."
end

__END__
# ElasticGraph Codebase Overview

ElasticGraph is designed to be modular, with a small core, and many built-in extensions that extend that core
for specific use cases. This minimizes exposure to vulnerabilities, reduces bloat, and makes ongoing upgrades
easier. The libraries that ship with ElasticGraph can be broken down into several categories.

<% gem_categories.each do |category| -%>
### <%= category.info.description %> (<%= category.gem_specs.size %> gems)

<%= category.info.discussion %>
<% category.gem_specs.each do |spec| -%>
* [<%= spec.name %>](<%= spec.name %>/README.md): <%= spec.summary %>
<% end -%>

#### Dependency Diagram

<%= category.mermaid_definition %>
<% end -%>
