#!/usr/bin/env ruby

require "erb"
require "fileutils"
require_relative "list_eg_gems"

module ElasticGraph
  class CodebaseOverviewRenderer
    PROJECT_ROOT = File.expand_path("..", __dir__)

    def initialize(template)
      @erb = ::ERB.new(template, trim_mode: "-")
    end

    def render
      @erb.result(binding)
    end

    def gem_specs
      @gem_specs ||= ::ElasticGraphGems.list.map do |gem_name|
        gemspec_path = File.join(PROJECT_ROOT, gem_name, "#{gem_name}.gemspec")
        unless File.exist?(gemspec_path)
          warn "Warning: Gemspec not found for #{gem_name} at #{gemspec_path}. Skipping."
          next nil
        end
        begin
          ::Gem::Specification.load(gemspec_path)
        rescue => e
          warn "Warning: Failed to load gemspec for #{gem_name} at #{gemspec_path}. Error: #{e.message}. Skipping."
          next nil
        end
      end.compact
    end

    def gem_categories
      @gem_categories ||= begin
        specs_by_category = gem_specs.group_by do |spec|
          spec.metadata.fetch("gem_category") { raise "No category set for #{spec.name}." }.tap do |category|
            unless CategoryInfo::BY_NAME.key?(category)
              raise "Unrecognized gem category `#{category}` found on gem: #{spec.name}."
            end
          end
        end

        CategoryInfo::BY_NAME.map do |category, category_info|
          specs = specs_by_category.fetch(category, [])
          GemCategory.new(category, category_info, specs, gem_specs)
        end
      end
    end
  end

  class IndividualGemReadmeProcessor
    STYLE_CURRENT_GEM = "fill:#AED6F1,stroke:#3498DB,color:#000,stroke-width:2px"      # Clearer Blue
    STYLE_INTERNAL_EG_GEM = "fill:#A9DFBF,stroke:#2ECC71,color:#000"                  # Clearer Green
    STYLE_EXTERNAL_GEM = "fill:#F4F6F7,stroke:#B3B6B7,color:#2980B9"                  # Light Grey, Blue text (link-like)

    def initialize(gem_spec, all_specs, project_root)
      @gem_spec = gem_spec
      @all_specs = all_specs
      @project_root = project_root
      @readme_path = File.join(@project_root, @gem_spec.name, "README.md")
    end

    def direct_dependencies
      @gem_spec.runtime_dependencies.map(&:name)
    end

    def direct_internal_dependents
      dependents = []
      current_gem_name = @gem_spec.name
      @all_specs.each do |other_spec|
        next if other_spec.name == current_gem_name
        if other_spec.runtime_dependencies.any? { |dep| dep.name == current_gem_name }
          dependents << other_spec.name
        end
      end
      dependents.uniq.sort
    end

    public def generate_mermaid_diagram
      deps = direct_dependencies
      dependents = direct_internal_dependents
      current_gem_name = @gem_spec.name

      mermaid_lines = ["graph LR;"]
      mermaid_lines << "    classDef currentGemStyle #{STYLE_CURRENT_GEM};"
      mermaid_lines << "    classDef internalEgGemStyle #{STYLE_INTERNAL_EG_GEM};"
      mermaid_lines << "    classDef externalGemStyle #{STYLE_EXTERNAL_GEM};"

      mermaid_lines << "    #{current_gem_name}[\"#{current_gem_name}\"];"
      mermaid_lines << "    class #{current_gem_name} currentGemStyle;"

      all_node_names_in_diagram = Set.new([current_gem_name])
      external_deps_for_links = Set.new

      unless deps.empty?
        deps.each do |dep_name|
          mermaid_lines << "    #{dep_name}[\"#{dep_name}\"];"
          mermaid_lines << "    #{current_gem_name} --> #{dep_name};"
          all_node_names_in_diagram.add(dep_name)
          is_internal = @all_specs.any? { |s| s.name == dep_name }
          mermaid_lines << "    class #{dep_name} #{is_internal ? 'internalEgGemStyle' : 'externalGemStyle'};"
          external_deps_for_links.add(dep_name) unless is_internal
        end
      end

      unless dependents.empty?
        dependents.each do |dep_name|
          mermaid_lines << "    #{dep_name}[\"#{dep_name}\"];"
          mermaid_lines << "    #{dep_name} --> #{current_gem_name};"
          all_node_names_in_diagram.add(dep_name)
          mermaid_lines << "    class #{dep_name} internalEgGemStyle;"
        end
      end

      external_deps_for_links.each do |ext_dep_name|
        mermaid_lines << "    click #{ext_dep_name} href \"https://rubygems.org/gems/#{ext_dep_name}\" \"Open on RubyGems.org\" _blank;"
      end

      "```mermaid\n#{mermaid_lines.join("\n")}\n```"
    end

    public def perform_readme_pre_flight_check
      unless File.exist?(@readme_path)
        return {status: :error, message: "README for #{@gem_spec.name} at #{@readme_path} is missing."}
      end
      content = File.read(@readme_path)
      if content.strip.empty?
        return {status: :error, message: "README for #{@gem_spec.name} at #{@readme_path} is empty."}
      end
      first_line = content.lines.first
      unless first_line && first_line.start_with?("# ")
        return {status: :error, message: "README for #{@gem_spec.name} at #{@readme_path} does not start with an H1 title."}
      end
      {status: :ok, content: content}
    end

    private def _isolate_intro_and_tail(readme_lines_after_h1)
      intro_lines = []
      tail_content_lines = []
      first_h2_or_diagram_heading_index = readme_lines_after_h1.find_index { |line| line.strip.start_with?("## ") }

      if first_h2_or_diagram_heading_index.nil?
        intro_lines = readme_lines_after_h1
      else
        intro_lines = readme_lines_after_h1[0...first_h2_or_diagram_heading_index]
        content_from_first_h2 = readme_lines_after_h1[first_h2_or_diagram_heading_index..]
        diagram_heading_index_in_remaining = content_from_first_h2.find_index { |line| line.strip == "## Dependency Diagram" }

        if diagram_heading_index_in_remaining.nil?
          tail_content_lines = content_from_first_h2
        else
          tail_content_lines.concat(content_from_first_h2[0...diagram_heading_index_in_remaining])
          current_search_index_in_remaining = diagram_heading_index_in_remaining + 1
          mermaid_block_started = false
          mermaid_block_ended = false
          while current_search_index_in_remaining < content_from_first_h2.length
            line_strip = content_from_first_h2[current_search_index_in_remaining].strip
            if !mermaid_block_started && line_strip == "```mermaid"
              mermaid_block_started = true
            elsif mermaid_block_started && !mermaid_block_ended && line_strip == "```"
              mermaid_block_ended = true
              current_search_index_in_remaining += 1
              break
            end
            current_search_index_in_remaining += 1
          end
          if mermaid_block_started
            if current_search_index_in_remaining < content_from_first_h2.length
              tail_content_lines.concat(content_from_first_h2[current_search_index_in_remaining..])
            end
          elsif diagram_heading_index_in_remaining + 1 < content_from_first_h2.length
            tail_content_lines.concat(content_from_first_h2[(diagram_heading_index_in_remaining + 1)..])
          end
        end
      end
      {
        intro_content: intro_lines.join.chomp,
        tail_content: tail_content_lines.join.chomp
      }
    end

    public def construct_expected_readme(actual_readme_content, new_mermaid_diagram_block)
      lines = actual_readme_content.lines
      h1_line = lines.first
      readme_lines_after_h1 = lines[1..] || []
      parsed_parts = _isolate_intro_and_tail(readme_lines_after_h1)
      components = [h1_line]
      intro_text = parsed_parts[:intro_content]
      if !intro_text.strip.empty?
        components << intro_text
        components << "\n"
      end
      components << "\n" unless components.last.end_with?("\n\n") || components.last.end_with?("\n") && components.length == 1
      components << "## Dependency Diagram\n"
      components << "\n"
      components << new_mermaid_diagram_block.strip
      components << "\n"
      tail_text = parsed_parts[:tail_content]
      if !tail_text.strip.empty?
        components << "\n"
        components << tail_text
      end
      final_content = components.join
      final_content += "\n" unless final_content.end_with?("\n")
      final_content.gsub(/\n{3,}/, "\n\n")
    end

    public def process
      pre_flight_result = perform_readme_pre_flight_check
      return pre_flight_result if pre_flight_result[:status] == :error
      actual_content = pre_flight_result[:content]
      new_mermaid_diagram = generate_mermaid_diagram
      expected_content = construct_expected_readme(actual_content, new_mermaid_diagram)
      {
        status: :ok,
        actual_content: actual_content,
        expected_content: expected_content,
        gem_name: @gem_spec.name,
        readme_path: @readme_path
      }
    end
  end

  class GemCategory < ::Data.define(:category_name, :info, :gem_specs, :all_eg_gem_specs)
    STYLE_CURRENT_CATEGORY_GEM = "fill:#AED6F1,stroke:#3498DB,color:#000,stroke-width:1.5px"  # Clearer Blue
    STYLE_OTHER_EG_GEM = "fill:#A9DFBF,stroke:#2ECC71,color:#000"                          # Clearer Green
    STYLE_EXTERNAL_CATEGORY_GEM = "fill:#F4F6F7,stroke:#B3B6B7,color:#2980B9"              # Light Grey, Blue text

    def mermaid_definition
      return "" if gem_specs.empty?
      class_defs = [
        "    classDef currentCategoryGemStyle #{STYLE_CURRENT_CATEGORY_GEM};",
        "    classDef otherEgGemStyle #{STYLE_OTHER_EG_GEM};",
        "    classDef externalGemCatStyle #{STYLE_EXTERNAL_CATEGORY_GEM};"
      ]
      node_definitions = all_nodes_in_category_diagrams.map { |name| "    #{name}[\"#{name}\"];" }

      <<~MERMAID
        ```mermaid
        graph LR;
        #{class_defs.join("\n")}
        #{node_definitions.uniq.join("\n")}
        #{mermaid_deps.join("\n")}
        #{mermaid_node_classes.join("\n")}
        #{mermaid_clicks.join("\n")}
        ```
      MERMAID
    end

    private

    def mermaid_deps
      gem_specs.flat_map do |spec|
        next if spec.runtime_dependencies.nil? || spec.runtime_dependencies.empty?
        spec.runtime_dependencies.map do |dep|
          "    #{spec.name} --> #{dep.name};"
        end
      end.compact
    end

    def all_nodes_in_category_diagrams
      nodes = Set.new
      gem_specs.each do |spec|
        nodes.add(spec.name)
        spec.runtime_dependencies.each { |dep| nodes.add(dep.name) }
      end
      nodes.to_a.compact.uniq
    end

    def mermaid_node_classes
      all_nodes_in_category_diagrams.map do |node_name|
        class_name = if gem_specs.any? { |spec| spec.name == node_name }
                       "currentCategoryGemStyle"
                     elsif all_eg_gem_specs.any? { |spec| spec.name == node_name }
                       "otherEgGemStyle"
                     else
                       "externalGemCatStyle"
                     end
        "    class #{node_name} #{class_name};"
      end
    end

    def mermaid_clicks
      all_nodes_in_category_diagrams.filter_map do |gem_name|
        is_internal_in_category = gem_specs.any? { |spec| spec.name == gem_name }
        is_other_eg_gem = all_eg_gem_specs.any? { |spec| spec.name == gem_name }
        unless is_internal_in_category || is_other_eg_gem
          "    click #{gem_name} href \"https://rubygems.org/gems/#{gem_name}\" \"Open on RubyGems.org\" _blank;"
        end
      end
    end
  end

  class CategoryInfo < ::Data.define(:description, :discussion)
    BY_NAME = {
      "core" => new("Core Libraries", <<~EOS),
        These libraries form the core backbone of ElasticGraph that is designed to run in a production deployment. Every ElasticGraph deployment will need to use all of these.
      EOS

      "lambda" => new("AWS Lambda Integration Libraries", <<~EOS),
        These libraries wrap the the core ElasticGraph libraries so that they can be deployed using AWS Lambda.
      EOS

      "extension" => new("Extensions", <<~EOS),
        These libraries extend ElasticGraph to provide optional but commonly needed functionality.
      EOS

      "datastore_adapter" => new("Datastore Adapters", <<~EOS),
        These libraries adapt ElasticGraph to your choice of datastore (Elasticsearch or OpenSearch).
      EOS

      "local" => new("Local Development Libraries", <<~EOS)
        These libraries are used for local development of ElasticGraph applications, but are not intended to be deployed to production (except for `elasticgraph-rack`).
        `elasticgraph-rack` is used to boot ElasticGraph locally but can also be used to run ElasticGraph in any rack-compatible server (including a Rails application).
      EOS
    }
  end
end

# --- Main script execution ---
renderer = ElasticGraph::CodebaseOverviewRenderer.new(DATA.read)
all_gem_specs = renderer.gem_specs # Load all gem specs once

readme_path_overview = ::File.join(ElasticGraph::CodebaseOverviewRenderer::PROJECT_ROOT, "CODEBASE_OVERVIEW.md")
readme_errors = [] # To collect errors for --verify mode

case ARGV.first
when "--verify"
  puts "Verifying CODEBASE_OVERVIEW.md..."
  generated_overview_contents = renderer.render
  if ::File.exist?(readme_path_overview) && ::File.read(readme_path_overview) == generated_overview_contents
    puts "‚úÖ CODEBASE_OVERVIEW.md is up-to-date."
  else
    tmp_path = ::File.join(ElasticGraph::CodebaseOverviewRenderer::PROJECT_ROOT, "tmp", "CODEBASE_OVERVIEW.md")
    ::FileUtils.mkdir_p(File.dirname(tmp_path)) # Ensure tmp directory exists
    ::File.write(tmp_path, generated_overview_contents)

    diff_command = "git diff --no-index --exit-code #{readme_path_overview} #{tmp_path}"
    diff_command += " --color" unless ENV["CI"]

    diff_output = `#{diff_command}`

    readme_errors << if $?.success?
      "‚ùå CODEBASE_OVERVIEW.md content mismatch but git diff shows no changes. Please investigate."
    else
      "‚ùå CODEBASE_OVERVIEW.md is out-of-date. Diff:\n#{diff_output}"
    end
  end

  puts "\nVerifying individual gem README dependency diagrams..."
  all_gem_specs.each do |spec|
    processor = ElasticGraph::IndividualGemReadmeProcessor.new(spec, all_gem_specs, ElasticGraph::CodebaseOverviewRenderer::PROJECT_ROOT)
    result = processor.process

    if result[:status] == :error
      readme_errors << "‚ùå Error processing #{spec.name}: #{result[:message]}"
    elsif result[:actual_content] == result[:expected_content]
      puts "‚úÖ #{spec.name} README diagram is up-to-date."
    else
      readme_errors << "‚ùå #{spec.name} README diagram at #{result[:readme_path]} is out-of-date or improperly formatted."
    end
  end

  if readme_errors.empty?
    puts "\nüéâ All dependency diagrams (CODEBASE_OVERVIEW.md and individual gems) are up-to-date."
    exit 0
  else
    puts "\n--- Verification Summary ---"
    readme_errors.each { |err| puts err }
    puts "\nScript verification failed. Please review the errors above."
    exit 1
  end

when nil # Default mode: update files
  puts "Updating CODEBASE_OVERVIEW.md..."
  generated_overview_contents = renderer.render
  ::File.write(readme_path_overview, generated_overview_contents)
  puts "‚úÖ CODEBASE_OVERVIEW.md updated."

  puts "\nUpdating individual gem README dependency diagrams..."
  all_gem_specs.each do |spec|
    puts "Processing gem #{spec.name}..."
    processor = ElasticGraph::IndividualGemReadmeProcessor.new(spec, all_gem_specs, ElasticGraph::CodebaseOverviewRenderer::PROJECT_ROOT)
    result = processor.process

    if result[:status] == :error
      puts "  ‚ùå Error: #{result[:message]}"
    elsif result[:actual_content] == result[:expected_content]
      puts "  ‚úÖ #{result[:readme_path]} dependency diagram is already up-to-date."
    else
      begin
        ::File.write(result[:readme_path], result[:expected_content])
        puts "  ‚úÖ #{result[:readme_path]} dependency diagram updated."
      rescue => e
        puts "  ‚ùå Failed to write #{result[:readme_path]}: #{e.message}"
      end
    end
  end
  puts "\nDependency diagram processing complete."
  exit 0

else
  warn "Unknown argument: #{ARGV.first}. Expected `--verify` or nothing."
  exit 1
end


__END__
# ElasticGraph Codebase Overview

ElasticGraph is designed to be modular, with a small core, and many built-in extensions that extend that core
for specific use cases. This minimizes exposure to vulnerabilities, reduces bloat, and makes ongoing upgrades
easier. The libraries that ship with ElasticGraph can be broken down into several categories.

<% gem_categories.each do |category| -%>
### <%= category.info.description %> (<%= category.gem_specs.size %> gems)

<%= category.info.discussion %>
<% category.gem_specs.each do |spec| -%>
* [<%= spec.name %>](<%= spec.name %>/README.md): <%= spec.summary %>
<% end -%>

#### Dependency Diagram

<%= category.mermaid_definition %>
<% end -%>
