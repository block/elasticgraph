#!/usr/bin/env ruby

require "erb"
require_relative "list_eg_gems"

module ElasticGraph
  class CodebaseOverviewRenderer
    PROJECT_ROOT = File.expand_path("..", __dir__)

    def initialize(template)
      @erb = ::ERB.new(template, trim_mode: "-")
    end

    def render
      @erb.result(binding)
    end

    def gem_specs
      @gem_specs ||= ::ElasticGraphGems.list.map do |gem_name|
        # Ensure gemspec path is absolute and correct
        gemspec_path = File.join(PROJECT_ROOT, gem_name, "#{gem_name}.gemspec")
        unless File.exist?(gemspec_path)
          # This should ideally not happen if ElasticGraphGems.list is accurate
          # but good for robustness if script is run in unusual states.
          warn "Warning: Gemspec not found for #{gem_name} at #{gemspec_path}. Skipping."
          next nil
        end
        begin
          ::Gem::Specification.load(gemspec_path)
        rescue => e
          warn "Warning: Failed to load gemspec for #{gem_name} at #{gemspec_path}. Error: #{e.message}. Skipping."
          next nil
        end
      end.compact # compact to remove any nils from failed loads
    end

    def gem_categories
      @gem_categories ||= begin
        specs_by_category = gem_specs.group_by do |spec|
          spec.metadata.fetch("gem_category") { raise "No category set for #{spec.name}." }.tap do |category|
            unless CategoryInfo::BY_NAME.key?(category)
              raise "Unrecognized gem category `#{category}` found on gem: #{spec.name}."
            end
          end
        end

        CategoryInfo::BY_NAME.map do |category, category_info|
          specs = specs_by_category.fetch(category, []) # Use fetch with default to avoid error if category has no gems
          GemCategory.new(category, category_info, specs, gem_specs)
        end
      end
    end
  end

  class IndividualGemReadmeProcessor
    def initialize(gem_spec, all_specs, project_root)
      @gem_spec = gem_spec
      @all_specs = all_specs # This should be an array of Gem::Specification objects
      @project_root = project_root
      @readme_path = File.join(@project_root, @gem_spec.name, "README.md")
    end

    def direct_dependencies
      @gem_spec.runtime_dependencies.map(&:name)
    end

    def direct_internal_dependents
      dependents = []
      current_gem_name = @gem_spec.name
      @all_specs.each do |other_spec|
        next if other_spec.name == current_gem_name
        if other_spec.runtime_dependencies.any? { |dep| dep.name == current_gem_name }
          dependents << other_spec.name
        end
      end
      dependents.uniq.sort
    end

    public def generate_mermaid_diagram
      deps = direct_dependencies
      dependents = direct_internal_dependents
      current_gem_name = @gem_spec.name

      mermaid_lines = ["graph LR;"]
      all_node_names_in_diagram = Set.new([current_gem_name])

      if deps.empty?
        mermaid_lines << "    #{current_gem_name} --> no_deps[(No direct dependencies)];"
        all_node_names_in_diagram.add("no_deps")
      else
        deps.each do |dep_name|
          mermaid_lines << "    #{current_gem_name} --> #{dep_name};"
          all_node_names_in_diagram.add(dep_name)
        end
      end

      if dependents.empty?
        mermaid_lines << "    no_eg_dependents[(No direct EG dependents)] --> #{current_gem_name};"
        all_node_names_in_diagram.add("no_eg_dependents")
      else
        dependents.each do |dep_name|
          mermaid_lines << "    #{dep_name} --> #{current_gem_name};"
          all_node_names_in_diagram.add(dep_name)
        end
      end

      mermaid_lines << "    classDef currentGemStyle fill:#lightblue,stroke:#333,stroke-width:2px;"
      mermaid_lines << "    classDef internalEgGemStyle fill:#lightgreen,stroke:#333,stroke-width:1px;"
      mermaid_lines << "    classDef externalGemStyle fill:#lightcoral,stroke:#333,stroke-width:1px;"
      mermaid_lines << "    classDef placeholderNodeStyle fill:#eee,stroke:#333,stroke-width:1px;"

      all_node_names_in_diagram.each do |node_name|
        style_class = case node_name
        when current_gem_name
          "currentGemStyle"
        when "no_deps", "no_eg_dependents"
          "placeholderNodeStyle"
        else
          # Check if it's an ElasticGraph gem (present in all_specs)
          if @all_specs.any? { |s| s.name == node_name }
            "internalEgGemStyle"
          else
            "externalGemStyle"
          end
        end
        mermaid_lines << "    class #{node_name} #{style_class};"
      end

      "```mermaid\n#{mermaid_lines.join("\n")}\n```"
    end

    public def perform_readme_pre_flight_check
      unless File.exist?(@readme_path)
        return {status: :error, message: "README for #{@gem_spec.name} at #{@readme_path} is missing."}
      end

      content = File.read(@readme_path)
      if content.strip.empty?
        return {status: :error, message: "README for #{@gem_spec.name} at #{@readme_path} is empty."}
      end

      first_line = content.lines.first
      unless first_line && first_line.start_with?("# ")
        return {status: :error, message: "README for #{@gem_spec.name} at #{@readme_path} does not start with an H1 title."}
      end

      {status: :ok, content: content}
    end

    private def _isolate_intro_and_tail(readme_lines_after_h1)
      intro_lines = []
      tail_content_lines = [] # Renamed for clarity

      # Find the index of the first H2 heading (e.g., "## Some Other Section")
      # or the specific "## Dependency Diagram" heading.
      first_h2_or_diagram_heading_index = readme_lines_after_h1.find_index do |line|
        line.strip.start_with?("## ")
      end

      if first_h2_or_diagram_heading_index.nil?
        # No H2 headings found after H1, so all remaining lines are considered intro.
        intro_lines = readme_lines_after_h1
      else
        # H2 heading(s) exist. Intro is everything before the first one.
        intro_lines = readme_lines_after_h1[0...first_h2_or_diagram_heading_index]

        # Now, from the first H2 onwards, find where the "## Dependency Diagram" section is (if it exists)
        # and what comes after it.
        content_from_first_h2 = readme_lines_after_h1[first_h2_or_diagram_heading_index..]

        diagram_heading_index_in_remaining = content_from_first_h2.find_index do |line|
          line.strip == "## Dependency Diagram"
        end

        if diagram_heading_index_in_remaining.nil?
          # "## Dependency Diagram" not found, so all content_from_first_h2 is considered tail.
          tail_content_lines = content_from_first_h2
        else
          # "## Dependency Diagram" found.
          # Tail starts with content before the diagram heading (if any H2s were before it).
          tail_content_lines.concat(content_from_first_h2[0...diagram_heading_index_in_remaining])

          # Now, skip the diagram heading and its Mermaid block.
          current_search_index_in_remaining = diagram_heading_index_in_remaining + 1 # Start after "## Dependency Diagram" line
          mermaid_block_started = false
          mermaid_block_ended = false

          while current_search_index_in_remaining < content_from_first_h2.length
            line_strip = content_from_first_h2[current_search_index_in_remaining].strip
            if !mermaid_block_started && line_strip == "```mermaid"
              mermaid_block_started = true
            elsif mermaid_block_started && !mermaid_block_ended && line_strip == "```"
              mermaid_block_ended = true
              # Move past the closing ```
              current_search_index_in_remaining += 1
              break # Found end of mermaid block
            end
            current_search_index_in_remaining += 1
          end

          # If a mermaid block was started (and potentially ended), append the rest of the content.
          if mermaid_block_started # Check if we even entered a mermaid block
            # If mermaid_block_ended is true, current_search_index_in_remaining is already past it.
            # If mermaid_block_ended is false, it means we hit EOF inside mermaid block (malformed)
            # or the block was empty. In any case, take from current_search_index_in_remaining.
            if current_search_index_in_remaining < content_from_first_h2.length
              tail_content_lines.concat(content_from_first_h2[current_search_index_in_remaining..])
            end
          elsif diagram_heading_index_in_remaining + 1 < content_from_first_h2.length
            # No mermaid block found after "## Dependency Diagram" heading,
            # so the rest of the content_from_first_h2 (after the heading line) is tail.
            tail_content_lines.concat(content_from_first_h2[(diagram_heading_index_in_remaining + 1)..])
          end
        end
      end

      # Join lines and strip only at the very end to preserve internal structure.
      # Ensure there are no excessive newlines between intro and the start of tail_content_lines.
      intro_str = intro_lines.join
      tail_str = tail_content_lines.join

      {
        intro_content: intro_str.chomp, # Chomp trailing newlines from intro part
        tail_content: tail_str.chomp    # Chomp trailing newlines from tail part
      }
    end

    public def construct_expected_readme(actual_readme_content, new_mermaid_diagram_block)
      lines = actual_readme_content.lines
      h1_line = lines.first # Keep its original newline

      readme_lines_after_h1 = lines[1..] || []
      parsed_parts = _isolate_intro_and_tail(readme_lines_after_h1)

      components = [h1_line] # h1_line includes its newline

      intro_text = parsed_parts[:intro_content]
      # Add intro if it's not just whitespace.
      # Ensure there's a blank line after intro if it's not empty,
      # or after H1 if intro is empty, before "## Dependency Diagram".
      if !intro_text.strip.empty?
        components << intro_text
        components << "\n" # Ensure separation if intro_text didn't end with \n\n
      end

      # Always ensure a blank line before the "## Dependency Diagram" heading,
      # unless the intro itself was empty and H1 already provided one.
      components << "\n" unless components.last.end_with?("\n\n") || components.last.end_with?("\n") && components.length == 1

      components << "## Dependency Diagram\n"
      components << "\n" # Blank line after heading
      components << new_mermaid_diagram_block.strip # Mermaid block itself
      components << "\n" # Blank line after mermaid block

      tail_text = parsed_parts[:tail_content]
      if !tail_text.strip.empty?
        components << "\n" # Ensure separation before tail_text
        components << tail_text
      end

      # Join all components. If any component already ends with sufficient newlines,
      # `join` handles it. Add a final newline if not present.
      final_content = components.join
      final_content += "\n" unless final_content.end_with?("\n")

      # Normalize multiple blank lines down to a single blank line (two newlines)
      final_content.gsub(/\n{3,}/, "\n\n")
    end

    public def process
      pre_flight_result = perform_readme_pre_flight_check

      return pre_flight_result if pre_flight_result[:status] == :error

      actual_content = pre_flight_result[:content]

      new_mermaid_diagram = generate_mermaid_diagram
      expected_content = construct_expected_readme(actual_content, new_mermaid_diagram)

      {
        status: :ok,
        actual_content: actual_content,
        expected_content: expected_content,
        gem_name: @gem_spec.name,
        readme_path: @readme_path
      }
    end
  end

  class GemCategory < ::Data.define(:category_name, :info, :gem_specs, :all_eg_gem_specs)
    def mermaid_definition
      return "" if gem_specs.empty? # Handle empty categories gracefully
      <<~MERMAID
        ```mermaid
        graph LR;
        #{mermaid_deps.join("\n")}
        #{mermaid_styles.join("\n")}
        #{mermaid_clicks.join("\n")}
        ```
      MERMAID
    end

    private

    def mermaid_deps
      gem_specs.filter_map do |spec|
        # Ensure spec.runtime_dependencies is not nil and not empty
        unless spec.runtime_dependencies.nil? || spec.runtime_dependencies.empty?
          # Ensure dependency names are valid for Mermaid node IDs (e.g., no special chars not handled by Mermaid)
          # For simple names, this is fine. Complex names might need sanitization.
          deps = spec.runtime_dependencies.map(&:name).join(" & ")
          "    #{spec.name} --> #{deps}"
        end
      end
    end

    def mermaid_styles
      all_nodes = gem_specs.map(&:name) | gem_specs.flat_map { |spec| spec.runtime_dependencies.map(&:name) }
      all_nodes.compact.uniq.map do |node| # Add compact and uniq for robustness
        "    style #{node} #{style_for(node)};"
      end
    end

    def style_for(gem_name)
      # These colors were chosen to look good on GitHub in both light mode and dark mode.
      if gem_specs.any? { |spec| spec.name == gem_name }
        "color: DodgerBlue" # Basic "Blue" doesn't look good in dark mode.
      elsif all_eg_gem_specs.any? { |spec| spec.name == gem_name }
        "color: Green"
      else
        "color: Red"
      end
    end

    def mermaid_clicks
      gem_specs.flat_map { |spec| spec.runtime_dependencies.map(&:name) }.compact.uniq.sort.filter_map do |gem_name|
        unless all_eg_gem_specs.any? { |spec| spec.name == gem_name }
          "click #{gem_name} href \"https://rubygems.org/gems/#{gem_name}\""
        end
      end
    end
  end

  class CategoryInfo < ::Data.define(:description, :discussion)
    BY_NAME = {
      "core" => new("Core Libraries", <<~EOS),
        These libraries form the core backbone of ElasticGraph that is designed to run in a production deployment. Every ElasticGraph deployment will need to use all of these.
      EOS

      "lambda" => new("AWS Lambda Integration Libraries", <<~EOS),
        These libraries wrap the the core ElasticGraph libraries so that they can be deployed using AWS Lambda.
      EOS

      "extension" => new("Extensions", <<~EOS),
        These libraries extend ElasticGraph to provide optional but commonly needed functionality.
      EOS

      "datastore_adapter" => new("Datastore Adapters", <<~EOS),
        These libraries adapt ElasticGraph to your choice of datastore (Elasticsearch or OpenSearch).
      EOS

      "local" => new("Local Development Libraries", <<~EOS)
        These libraries are used for local development of ElasticGraph applications, but are not intended to be deployed to production (except for `elasticgraph-rack`).
        `elasticgraph-rack` is used to boot ElasticGraph locally but can also be used to run ElasticGraph in any rack-compatible server (including a Rails application).
      EOS
    }
  end
end

# --- Main script execution ---
renderer = ElasticGraph::CodebaseOverviewRenderer.new(DATA.read)
all_gem_specs = renderer.gem_specs # Load all gem specs once

readme_path_overview = ::File.join(ElasticGraph::CodebaseOverviewRenderer::PROJECT_ROOT, "CODEBASE_OVERVIEW.md")
readme_errors = [] # To collect errors for --verify mode

case ARGV.first
when "--verify"
  puts "Verifying CODEBASE_OVERVIEW.md..."
  generated_overview_contents = renderer.render
  if ::File.exist?(readme_path_overview) && ::File.read(readme_path_overview) == generated_overview_contents
    puts "✅ CODEBASE_OVERVIEW.md is up-to-date."
  else
    tmp_path = ::File.join(ElasticGraph::CodebaseOverviewRenderer::PROJECT_ROOT, "tmp", "CODEBASE_OVERVIEW.md")
    ::FileUtils.mkdir_p(File.dirname(tmp_path)) # Ensure tmp directory exists
    ::File.write(tmp_path, generated_overview_contents)

    diff_command = "git diff --no-index --exit-code #{readme_path_overview} #{tmp_path}"
    diff_command += " --color" unless ENV["CI"]

    diff_output = `#{diff_command}`

    readme_errors << if $?.success? # No diff means files are the same, but File.read check failed. Should not happen.
      "❌ CODEBASE_OVERVIEW.md content mismatch but git diff shows no changes. Please investigate."
    else
      "❌ CODEBASE_OVERVIEW.md is out-of-date. Diff:\n#{diff_output}"
    end
  end

  puts "\nVerifying individual gem README dependency diagrams..."
  all_gem_specs.each do |spec|
    processor = ElasticGraph::IndividualGemReadmeProcessor.new(spec, all_gem_specs, ElasticGraph::CodebaseOverviewRenderer::PROJECT_ROOT)
    result = processor.process

    if result[:status] == :error
      readme_errors << "❌ Error processing #{spec.name}: #{result[:message]}"
    elsif result[:actual_content] == result[:expected_content]
      # In verify mode, we check if actual content matches expected content
      puts "✅ #{spec.name} README diagram is up-to-date."
    else
      readme_errors << "❌ #{spec.name} README diagram at #{result[:readme_path]} is out-of-date or improperly formatted."
      # Optionally, provide a diff for individual READMEs if desired (more complex)
      # For now, just a message.
    end
  end

  if readme_errors.empty?
    puts "\n🎉 All dependency diagrams (CODEBASE_OVERVIEW.md and individual gems) are up-to-date."
    exit 0
  else
    puts "\n--- Verification Summary ---"
    readme_errors.each { |err| puts err }
    puts "\nScript verification failed. Please review the errors above."
    exit 1
  end

when nil # Default mode: update files
  puts "Updating CODEBASE_OVERVIEW.md..."
  generated_overview_contents = renderer.render
  ::File.write(readme_path_overview, generated_overview_contents)
  puts "✅ CODEBASE_OVERVIEW.md updated."

  puts "\nUpdating individual gem README dependency diagrams..."
  all_gem_specs.each do |spec|
    puts "Processing gem #{spec.name}..."
    processor = ElasticGraph::IndividualGemReadmeProcessor.new(spec, all_gem_specs, ElasticGraph::CodebaseOverviewRenderer::PROJECT_ROOT)
    result = processor.process

    if result[:status] == :error
      puts "  ❌ Error: #{result[:message]}"
    elsif result[:actual_content] == result[:expected_content]
      puts "  ✅ #{result[:readme_path]} dependency diagram is already up-to-date."
    else
      begin
        ::File.write(result[:readme_path], result[:expected_content])
        puts "  ✅ #{result[:readme_path]} dependency diagram updated."
      rescue => e
        puts "  ❌ Failed to write #{result[:readme_path]}: #{e.message}"
      end
    end
  end
  puts "\nDependency diagram processing complete."
  exit 0

else
  warn "Unknown argument: #{ARGV.first}. Expected `--verify` or nothing."
  exit 1
end


__END__
# ElasticGraph Codebase Overview

ElasticGraph is designed to be modular, with a small core, and many built-in extensions that extend that core
for specific use cases. This minimizes exposure to vulnerabilities, reduces bloat, and makes ongoing upgrades
easier. The libraries that ship with ElasticGraph can be broken down into several categories.

<% gem_categories.each do |category| -%>
### <%= category.info.description %> (<%= category.gem_specs.size %> gems)

<%= category.info.discussion %>
<% category.gem_specs.each do |spec| -%>
* [<%= spec.name %>](<%= spec.name %>/README.md): <%= spec.summary %>
<% end -%>

#### Dependency Diagram

<%= category.mermaid_definition %>
<% end -%>
